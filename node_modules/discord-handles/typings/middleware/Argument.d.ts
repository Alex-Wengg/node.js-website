import HandlesClient from '../core/Client';
import Command from '../structures/Command';
import { Message } from 'discord.js';
/**
 * This is called every time new potential argument data is received, either in the body of
 * the original command or in subsequent prompts.
 */
export declare type Resolver<T> = (content: string, message: Message, arg: Argument<T>) => T | null;
export interface IOptions<T> {
    prompt?: string;
    rePrompt?: string;
    optional?: boolean;
    resolver?: Resolver<T>;
    timeout?: number;
    pattern?: RegExp;
    suffix?: string | null;
}
/**
 * This function takes a string which contains any number of arguments and returns the first of them.
 * The return should be a substring of the input, which will then be removed from the input string. The remaining
 * input will be fed back into this function for the next argument, etc. until no more arguments remain. Use this
 * to determine whether an argument *exists*; use [[Argument#resolver]] to determine if the argument is *valid*.
 */
export declare type Matcher = (content: string) => string;
/**
 * Represents a command argument.
 */
export default class Argument<T = string> implements IOptions<T>, Promise<T> {
    readonly command: Command;
    /**
     * The key that this arg will be set to.
     *
     * ```js
     * // in args definition
     * new Argument('thing');
     *
     * // in command execution
     * const thingData = command.args.thing;
     * ```
     */
    key: string;
    /**
     * The initial prompt text of this argument.
     */
    prompt: string;
    /**
     * Text sent for re-prompting to provide correct input when provided input is not resolved
     * (ie. the resolver returns null).
     */
    rePrompt: string;
    /**
     * Whether this argument is optional.
     */
    optional: boolean;
    /**
     * The argument resolver for this argument.
     */
    resolver: Resolver<T>;
    /**
     * How long to wait for a response to a prompt, in seconds.
     */
    timeout: number;
    /**
     * Text to append to each prompt.  Defaults to global setting or built-in text.
     */
    suffix: string | null;
    /**
     * The matcher for this argument.
     */
    matcher: Matcher;
    /**
     * The raw content matching regex.
     */
    private _pattern;
    constructor(command: Command, key: string, {prompt, rePrompt, optional, timeout, suffix, pattern}?: IOptions<T>);
    readonly handles: HandlesClient;
    /**
     * A regex describing the pattern of arguments.  Defaults to single words.  If more advanced matching
     * is required, set a custom [[matcher]] instead.  Can pull arguments from anywhere in the unresolved
     * content, so make sure to specify `^` if you want to pull from the front.
     */
    pattern: RegExp;
    /**
     * Make this argument take up the rest of the words in the command. Any remaining required arguments
     * will be prompted for.
     */
    setInfinite(): this;
    /**
     * Set the pattern for matching args strings.
     */
    setPattern(pattern: RegExp): this;
    /**
     * Set the prompt for the argument.
     */
    setPrompt(prompt?: string): this;
    /**
     * Set the re-prompt for the argument.
     */
    setRePrompt(rePrompt?: string): this;
    /**
     * Set whether the argument is optional.
     */
    setOptional(optional?: boolean): this;
    /**
     * Set the argument resolver function for this argument.
     */
    setResolver(resolver: Resolver<T>): this;
    /**
     * Set the time to wait for a prompt response (in seconds).
     */
    setTimeout(time?: number): this;
    /**
     * Set the suffix for all prompts.
     */
    setSuffix(text?: string): this;
    then<TResult1 = T, TResult2 = never>(resolver?: ((value: T | null) => TResult1 | PromiseLike<TResult1>), rejector?: ((value: Error) => TResult2 | PromiseLike<TResult2>)): Promise<TResult1 | TResult2>;
    catch<TResult2 = never>(rejector?: ((value: Error) => TResult2 | PromiseLike<TResult2>)): Promise<T | TResult2>;
    readonly [Symbol.toStringTag]: 'Promise';
    private collectPrompt(first?);
}
