"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Queue_1 = require("../util/Queue");
/**
 * Send responses to a message.
 */
class Response {
    /**
     * @param message The message to respond to.
     * @param edit Whether to edit previous responses.
     */
    constructor(message, edit = true) {
        /**
         * Whether to edit previous responses.
         */
        this.edit = true;
        /**
         * Send a message using the Discord.js `Message.send` method.  If a prior
         * response has been sent, it will edit that unless the `force` parameter
         * is set.  Automatically attempts to fallback to DM responses.  You can
         * send responses without waiting for prior responses to succeed.
         * @param data The data to send
         * @param options Message options.
         * @param messageOptions Discord.js message options.
         */
        this.send = (data, options = {}, ...extra) => {
            options = Object.assign(options, ...extra);
            return new Promise((resolve, reject) => {
                this._q.push(() => __awaiter(this, void 0, void 0, function* () {
                    function success(m) {
                        resolve(m);
                    }
                    function error(e) {
                        if (options.catchall)
                            return success();
                        reject(e);
                    }
                    if (this.responseMessage && this.edit && !options.force) {
                        yield this.responseMessage.edit(data, options).then(success, error);
                    }
                    else {
                        yield this.channel.send(data, options).then((m) => {
                            if (Array.isArray(m))
                                this.responseMessage = m[0];
                            else
                                this.responseMessage = m;
                            return success(m);
                        }, () => {
                            if (this.channel.type === 'text') {
                                return this.message.author.send(data, options).then(success, error);
                            }
                        });
                    }
                }));
            });
        };
        this.error = (data, ...options) => {
            return this.send(`\`❌\` | ${data}`, ...options);
        };
        this.success = (data, ...options) => {
            return this.send(`\`✅\` | ${data}`, ...options);
        };
        this.dm = (data, ...options) => __awaiter(this, void 0, void 0, function* () {
            this.channel = this.message.author.dmChannel || (yield this.message.author.createDM());
            return this.send(data, ...options);
        });
        this.message = message;
        this.channel = message.channel;
        this.edit = edit;
        this.responseMessage = null;
        this._q = new Queue_1.default();
    }
}
exports.default = Response;

//# sourceMappingURL=Response.js.map
