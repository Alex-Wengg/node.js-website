"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ArgumentError_1 = require("../errors/ArgumentError");
/**
 * Represents a command argument.
 */
class Argument {
    constructor(command, key, { prompt = '', rePrompt = '', optional = false, timeout = 30, suffix = null, pattern = /^\S+/, } = {}) {
        /**
         * Whether this argument is optional.
         */
        this.optional = false;
        this.command = command;
        this.key = key;
        this.prompt = prompt;
        this.rePrompt = rePrompt;
        this.optional = optional;
        this.timeout = timeout;
        this.suffix = suffix;
        this.pattern = pattern;
    }
    get handles() {
        return this.command.handles;
    }
    /**
     * A regex describing the pattern of arguments.  Defaults to single words.  If more advanced matching
     * is required, set a custom [[matcher]] instead.  Can pull arguments from anywhere in the unresolved
     * content, so make sure to specify `^` if you want to pull from the front.
     */
    get pattern() {
        return this._pattern;
    }
    set pattern(regex) {
        this._pattern = regex;
        this.matcher = (content) => {
            const m = content.match(regex);
            return m === null ? '' : m[0];
        };
    }
    /**
     * Make this argument take up the rest of the words in the command. Any remaining required arguments
     * will be prompted for.
     */
    setInfinite() {
        return this.setPattern(/.*/);
    }
    /**
     * Set the pattern for matching args strings.
     */
    setPattern(pattern) {
        this.pattern = pattern;
        return this;
    }
    /**
     * Set the prompt for the argument.
     */
    setPrompt(prompt = '') {
        this.prompt = prompt;
        return this;
    }
    /**
     * Set the re-prompt for the argument.
     */
    setRePrompt(rePrompt = '') {
        this.rePrompt = rePrompt;
        return this;
    }
    /**
     * Set whether the argument is optional.
     */
    setOptional(optional = true) {
        this.optional = optional;
        return this;
    }
    /**
     * Set the argument resolver function for this argument.
     */
    setResolver(resolver) {
        this.resolver = resolver;
        return this;
    }
    /**
     * Set the time to wait for a prompt response (in seconds).
     */
    setTimeout(time = 30) {
        this.timeout = time;
        return this;
    }
    /**
     * Set the suffix for all prompts.
     */
    setSuffix(text = '') {
        this.suffix = text;
        return this;
    }
    then(resolver, rejector) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const matched = this.matcher(this.command.body);
            this.command.body = this.command.body.replace(matched, '').trim();
            const resolver = this.resolver || ((c) => c);
            let resolved = !matched ? null : yield resolver(matched, this.command.message, this);
            // if there is no matched content and the argument is not optional, collect a prompt
            if (resolved === null && !this.optional) {
                try {
                    resolved = yield this.collectPrompt(matched.length === 0);
                }
                catch (e) {
                    this.command.response.send('Command cancelled.');
                    if (e instanceof Map && !e.size)
                        e = new ArgumentError_1.default(this, 'time');
                    return reject(e);
                }
            }
            if (!this.command.args)
                this.command.args = {};
            this.command.args[this.key] = resolved;
            return resolve(resolved);
        })).then(resolver, rejector);
    }
    catch(rejector) {
        return this.then(undefined, rejector);
    }
    get [Symbol.toStringTag]() {
        return 'Promise';
    }
    collectPrompt(first = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const text = first ? this.prompt : this.rePrompt;
            const suffix = this.suffix || this.handles.argsSuffix ||
                `\nCommand will be cancelled in **${this.timeout} seconds**.  Type \`cancel\` to cancel immediately.`;
            // get first response
            const prompt = new this.handles.Response(this.command.message);
            yield prompt.send(text + suffix);
            const responses = yield prompt.channel.awaitMessages((m) => m.author.id === this.command.author.id, { time: this.timeout * 1000, max: 1, errors: ['time'] });
            const response = responses.first();
            // cancel
            if (response.content === 'cancel')
                throw new ArgumentError_1.default(this, 'cancelled');
            // resolve: if not, prompt again
            const resolved = yield this.resolver(response.content, response, this);
            if (resolved === null)
                return this.collectPrompt(false);
            return resolved;
        });
    }
}
exports.default = Argument;

//# sourceMappingURL=Argument.js.map
