{"version":3,"sources":["middleware/Argument.ts"],"names":[],"mappings":"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","file":"Argument.js","sourcesContent":["import HandlesClient from '../core/Client';\nimport ArgumentError from '../errors/ArgumentError';\nimport Command from '../structures/Command';\nimport Response from '../structures/Response';\n\nimport { Message } from 'discord.js';\n\n/**\n * This is called every time new potential argument data is received, either in the body of\n * the original command or in subsequent prompts.\n */\nexport type Resolver<T> = (content: string, message: Message, arg: Argument<T>) => T | null;\n\nexport interface IOptions<T> {\n  prompt?: string;\n  rePrompt?: string;\n  optional?: boolean;\n  resolver?: Resolver<T>;\n  timeout?: number;\n  pattern?: RegExp;\n  suffix?: string | null;\n}\n\n/**\n * This function takes a string which contains any number of arguments and returns the first of them.\n * The return should be a substring of the input, which will then be removed from the input string. The remaining\n * input will be fed back into this function for the next argument, etc. until no more arguments remain. Use this\n * to determine whether an argument *exists*; use [[Argument#resolver]] to determine if the argument is *valid*.\n */\nexport type Matcher = (content: string) => string;\n\n/**\n * Represents a command argument.\n */\nexport default class Argument<T = string> implements IOptions<T>, Promise<T> {\n  public readonly command: Command;\n\n  /**\n   * The key that this arg will be set to.\n   *\n   * ```js\n   * // in args definition\n   * new Argument('thing');\n   *\n   * // in command execution\n   * const thingData = command.args.thing;\n   * ```\n   */\n  public key: string;\n\n  /**\n   * The initial prompt text of this argument.\n   */\n  public prompt: string;\n\n  /**\n   * Text sent for re-prompting to provide correct input when provided input is not resolved\n   * (ie. the resolver returns null).\n   */\n  public rePrompt: string;\n\n  /**\n   * Whether this argument is optional.\n   */\n  public optional: boolean = false;\n\n  /**\n   * The argument resolver for this argument.\n   */\n  public resolver: Resolver<T>;\n\n  /**\n   * How long to wait for a response to a prompt, in seconds.\n   */\n  public timeout: number;\n\n  /**\n   * Text to append to each prompt.  Defaults to global setting or built-in text.\n   */\n  public suffix: string | null;\n\n  /**\n   * The matcher for this argument.\n   */\n  public matcher: Matcher;\n\n  /**\n   * The raw content matching regex.\n   */\n  private _pattern: RegExp;\n\n  constructor(command: Command, key: string, {\n    prompt = '',\n    rePrompt = '',\n    optional = false,\n    timeout = 30,\n    suffix = null,\n    pattern = /^\\S+/,\n  }: IOptions<T> = {}) {\n    this.command = command;\n    this.key = key;\n\n    this.prompt = prompt;\n    this.rePrompt = rePrompt;\n    this.optional = optional;\n    this.timeout = timeout;\n    this.suffix = suffix;\n    this.pattern = pattern;\n  }\n\n  get handles(): HandlesClient {\n    return this.command.handles;\n  }\n\n  /**\n   * A regex describing the pattern of arguments.  Defaults to single words.  If more advanced matching\n   * is required, set a custom [[matcher]] instead.  Can pull arguments from anywhere in the unresolved\n   * content, so make sure to specify `^` if you want to pull from the front.\n   */\n  get pattern() {\n    return this._pattern;\n  }\n\n  set pattern(regex) {\n    this._pattern = regex;\n\n    this.matcher = (content) => {\n      const m = content.match(regex);\n      return m === null ? '' : m[0];\n    };\n  }\n\n  /**\n   * Make this argument take up the rest of the words in the command. Any remaining required arguments\n   * will be prompted for.\n   */\n  public setInfinite() {\n    return this.setPattern(/.*/);\n  }\n\n  /**\n   * Set the pattern for matching args strings.\n   */\n  public setPattern(pattern: RegExp) {\n    this.pattern = pattern;\n    return this;\n  }\n\n  /**\n   * Set the prompt for the argument.\n   */\n  public setPrompt(prompt: string = '') {\n    this.prompt = prompt;\n    return this;\n  }\n\n  /**\n   * Set the re-prompt for the argument.\n   */\n  public setRePrompt(rePrompt: string = '') {\n    this.rePrompt = rePrompt;\n    return this;\n  }\n\n  /**\n   * Set whether the argument is optional.\n   */\n  public setOptional(optional: boolean = true) {\n    this.optional = optional;\n    return this;\n  }\n\n  /**\n   * Set the argument resolver function for this argument.\n   */\n  public setResolver(resolver: Resolver<T>) {\n    this.resolver = resolver;\n    return this;\n  }\n\n  /**\n   * Set the time to wait for a prompt response (in seconds).\n   */\n  public setTimeout(time: number = 30) {\n    this.timeout = time;\n    return this;\n  }\n\n  /**\n   * Set the suffix for all prompts.\n   */\n  public setSuffix(text: string = '') {\n    this.suffix = text;\n    return this;\n  }\n\n  public then<TResult1 = T, TResult2 = never>(\n    resolver?: ((value: T | null) => TResult1 | PromiseLike<TResult1>),\n    rejector?: ((value: Error) => TResult2 | PromiseLike<TResult2>),\n  ): Promise<TResult1 | TResult2> {\n    return new Promise<T | null>(async (resolve, reject) => {\n      const matched = this.matcher(this.command.body);\n      this.command.body = this.command.body.replace(matched, '').trim();\n\n      const resolver = this.resolver || ((c: string) => c);\n      let resolved = !matched ? null : await resolver(matched, this.command.message, this);\n\n      // if there is no matched content and the argument is not optional, collect a prompt\n      if (resolved === null && !this.optional) {\n        try {\n          resolved = await this.collectPrompt(matched.length === 0);\n        } catch (e) {\n          this.command.response.send('Command cancelled.');\n          if (e instanceof Map && !e.size) e = new ArgumentError<T>(this, 'time');\n          return reject(e);\n        }\n      }\n\n      if (!this.command.args) this.command.args = {};\n      this.command.args[this.key] = resolved;\n\n      return resolve(resolved);\n    }).then(resolver, rejector);\n  }\n\n  public catch<TResult2 = never>(rejector?: ((value: Error) => TResult2 | PromiseLike<TResult2>)) {\n    return this.then(undefined, rejector);\n  }\n\n  public get [Symbol.toStringTag](): 'Promise' {\n    return 'Promise';\n  }\n\n  private async collectPrompt(first = true): Promise<T> {\n    const text = first ? this.prompt : this.rePrompt;\n    const suffix = this.suffix || this.handles.argsSuffix ||\n      `\\nCommand will be cancelled in **${this.timeout} seconds**.  Type \\`cancel\\` to cancel immediately.`;\n\n    // get first response\n    const prompt = new this.handles.Response(this.command.message);\n    await prompt.send(text + suffix);\n    const responses = await prompt.channel.awaitMessages(\n      (m: Message) => m.author.id === this.command.author.id,\n      { time: this.timeout * 1000, max: 1, errors: ['time'] },\n    );\n    const response = responses.first();\n\n    // cancel\n    if (response.content === 'cancel') throw new ArgumentError<T>(this, 'cancelled');\n\n    // resolve: if not, prompt again\n    const resolved = await this.resolver(response.content, response, this);\n    if (resolved === null) return this.collectPrompt(false);\n\n    return resolved;\n  }\n}\n"],"sourceRoot":"../../src"}