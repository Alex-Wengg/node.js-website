"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ValidationError_1 = require("../errors/ValidationError");
/**
 * Passed as a parameter to command validators.  Arguments will not be available in this class,
 * as this is run before arguments are resolved from the command.  Use for permissions checks and
 * other pre-command validations.
 *
 * ```js
 * // Using a custom validator.
 * class CustomValidator extends Validator {
 *   ensureGuild() {
 *     return this.apply(this.command.message.channel.type === 'text', 'Command must be run in a guild channel.');
 *   }
 * }
 *
 * // Usage in command
 * exports.validator = processor => {
 *   return processor.ensureGuild();
 * }
 * ```
 *
 * ```js
 * // Usage without a custom validator
 * exports.validator = (processor, command) => {
 *   return processor.apply(command.message.channel.type === 'text', 'Command must be run in a guild channel.');
 * }
 * ```
 */
class Validator {
    constructor(cmd) {
        /**
         * The reason this validator is invalid.
         */
        this.reason = null;
        /**
         * Whether to automatically respond with reason when invalid.
         */
        this.respond = true;
        /**
         * Whether this validator is valid.
         */
        this.valid = true;
        /**
         * Functions to execute when determining validity. Maps validation functions to reasons.
         */
        this.exec = new Map();
        this.command = cmd;
    }
    /**
     * Test a new boolean for validity.
     *
     * ```js
     * const validator = new Validator();
     * validator.apply(aCondition, 'borke') || validator.apply(otherCondition, 'different borke');
     * yield validator;
     * ```
     */
    apply(test, reason = null) {
        this.exec.set(typeof test === 'function' ? test : () => test, reason);
        return this;
    }
    then(resolver, rejector) {
        return new Promise((resolve, reject) => {
            for (const [test, reason] of this.exec) {
                try {
                    if (!test(this)) {
                        this.reason = reason;
                        this.valid = false;
                        throw new ValidationError_1.default(this);
                    }
                }
                catch (e) {
                    if (this.respond)
                        this.command.response.error(e);
                    return reject(e);
                }
            }
            return resolve();
        }).then(resolver, rejector);
    }
}
exports.default = Validator;

//# sourceMappingURL=Validator.js.map
