"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tsubaki_1 = require("tsubaki");
const fs = require("fs");
const path = require("path");
const readdir = tsubaki_1.promisify(fs.readdir);
const stat = tsubaki_1.promisify(fs.stat);
/**
 * Manage command loading.
 */
class CommandRegistry extends Map {
    /**
     * Get all the file paths recursively in a directory.
     * @param dir The directory to start at.
     */
    static _loadDir(dir) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = yield readdir(dir);
            const list = [];
            yield Promise.all(files.map((f) => __awaiter(this, void 0, void 0, function* () {
                const currentPath = path.join(dir, f);
                const stats = yield stat(currentPath);
                if (stats.isFile() && path.extname(currentPath) === '.js') {
                    list.push(currentPath);
                }
                else if (stats.isDirectory()) {
                    const files = yield this._loadDir(currentPath);
                    list.push(...files);
                }
            })));
            return list;
        });
    }
    constructor(handles, config) {
        super();
        this.handles = handles;
        this.directory = config.directory || './commands';
        this.load();
    }
    /**
     * Load all commands into memory.  Use when reloading commands.
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            this.clear();
            const files = yield CommandRegistry._loadDir(this.directory);
            const failed = [];
            for (const file of files) {
                let mod;
                const location = path.resolve(process.cwd(), file);
                try {
                    delete require.cache[require.resolve(location)];
                    mod = require(location);
                }
                catch (e) {
                    failed.push(file);
                    console.error(e); // tslint:disable-line no-console
                    continue;
                }
                if (typeof mod.default !== 'undefined')
                    mod = mod.default;
                // if triggers are iterable
                if (Array.isArray(mod.triggers)) {
                    for (const trigger of mod.triggers)
                        this.set(trigger, mod);
                }
                else if (typeof mod.triggers === 'undefined') {
                    this.set(path.basename(file, '.js'), mod);
                }
                else {
                    this.set(mod.triggers, mod);
                }
            }
            this.handles.emit('commandsLoaded', { commands: this, failed, time: Date.now() - start });
            return this;
        });
    }
}
exports.default = CommandRegistry;

//# sourceMappingURL=CommandRegistry.js.map
