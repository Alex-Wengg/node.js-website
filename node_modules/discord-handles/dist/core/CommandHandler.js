"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseError_1 = require("../errors/BaseError");
/**
 * Class for handling a command.
 */
class CommandHandler {
    constructor(handles, config) {
        /**
         * Sessions to ignore.
         */
        this.ignore = [];
        /**
         * Methods to run before each command. Executed in sequence before the command's `pre` method.
         * **Deprecated:** the command parameter will be removed.
         */
        this.pre = [];
        /**
         * Methods to run after each command.  Executed in sequence after the command's `post` method.
         * **Deprecated:** the command parameter will be removed.
         */
        this.post = [];
        /**
         * Recently executed commands. Stored regardless of success or failure.
         */
        this.executed = [];
        this.handles = handles;
        this.silent = typeof config.silent === 'undefined' ? true : config.silent;
        if (typeof config.validator !== 'function' &&
            (!this.handles.prefixes || !this.handles.prefixes.size))
            throw new Error('Unable to validate commands: no validator or prefixes were provided.');
        this.validator = config.validator || ((message) => {
            for (const p of this.handles.prefixes) {
                if (message.content.startsWith(p)) {
                    return message.content.substring(p.length).trim();
                }
            }
            return null;
        });
    }
    /**
     * Resolve a command from a message.
     */
    resolve(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const content = yield this.validator(message);
            if (typeof content !== 'string' || !content)
                return null;
            const match = content.match(/^([^\s]+)(.*)/);
            if (match) {
                const [, cmd, commandContent] = match;
                const mod = this.handles.registry.get(cmd);
                if (mod) {
                    return new mod(this.handles, {
                        body: commandContent.trim(),
                        message,
                        trigger: cmd,
                    });
                }
            }
            for (const [trigger, command] of this.handles.registry) {
                let body = null;
                if (trigger instanceof RegExp) {
                    const match = content.match(trigger);
                    if (match)
                        body = match[0].trim();
                }
                else if (typeof trigger === 'string') {
                    // if the trigger is lowercase, make the command case-insensitive
                    if ((trigger.toLowerCase() === trigger ? content.toLowerCase() : content).startsWith(trigger)) {
                        body = content.substring(trigger.length).trim();
                    }
                }
                if (body !== null) {
                    const cmd = new command(this.handles, {
                        body,
                        message,
                        trigger,
                    });
                    if (!this.ignore.includes(cmd.session))
                        return cmd;
                }
            }
            return null;
        });
    }
    /**
     * Execute a command message.
     */
    exec(cmd) {
        return __awaiter(this, void 0, void 0, function* () {
            this._ignore(cmd.session);
            this.handles.emit('commandStarted', cmd);
            try {
                // TODO: Remove the param on global pre and post for v8
                for (const fn of this.pre)
                    yield fn.call(cmd, cmd);
                yield cmd.pre.call(cmd);
                const result = yield cmd.exec.call(cmd);
                yield cmd.post.call(cmd);
                for (const fn of this.post)
                    yield fn.call(cmd, cmd);
                this.handles.emit('commandFinished', { command: cmd, result });
                return this.silent ? result : undefined;
            }
            catch (e) {
                try {
                    yield cmd.error();
                }
                catch (e) {
                    // do nothing
                }
                if (e instanceof BaseError_1.default) {
                    this.handles.emit('commandFailed', { command: cmd, error: e });
                    if (!this.silent)
                        return e;
                }
                else {
                    this.handles.emit('commandError', { command: cmd, error: e });
                    if (!this.silent)
                        throw e;
                }
            }
            finally {
                this.executed.push(cmd);
                setTimeout(() => this.executed.splice(this.executed.indexOf(cmd), 1), 60 * 60 * 1000);
                this._unignore(cmd.session);
            }
        });
    }
    /**
     * Ignore something (designed for [[CommandMessage#session]]).
     * @param session The data to ignore.
     */
    _ignore(session) {
        this.ignore.push(session);
    }
    /**
     * Stop ignoring something (designed for [[CommandMessage#session]]).
     * @param session The data to unignore.
     */
    _unignore(session) {
        const index = this.ignore.indexOf(session);
        if (index > -1)
            this.ignore.splice(index, 1);
    }
}
exports.default = CommandHandler;

//# sourceMappingURL=CommandHandler.js.map
